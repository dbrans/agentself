"""SourceGenerator: Dehydrate runtime state to source code.

This module handles the conversion of runtime modifications back to
Python source code that can be persisted to files.
"""

from __future__ import annotations

import ast
import inspect
import textwrap
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from agentself.agent import Agent
    from agentself.tracker import AgentChanges


@dataclass
class GeneratedSource:
    """Result of source generation."""

    filename: str
    content: str
    is_valid: bool
    validation_error: str | None = None


class SourceGenerator:
    """Generates Python source code from runtime agent state.

    The generator takes an agent and its recorded changes, and produces
    valid Python source code that can be written to disk.
    """

    def __init__(self, agent: Agent):
        self.agent = agent

    def validate_source(self, source: str) -> tuple[bool, str | None]:
        """Validate that source is syntactically correct Python."""
        try:
            ast.parse(source)
            return True, None
        except SyntaxError as e:
            return False, f"Syntax error: {e}"

    def generate_tool_source(self, name: str, source: str) -> str:
        """Generate properly decorated tool source code."""
        # Ensure proper indentation
        source = textwrap.dedent(source)

        # Check if @tool decorator is present
        if not source.strip().startswith("@tool"):
            source = "@tool\n" + source

        return source

    def generate_modified_tools_module(self, changes: AgentChanges) -> GeneratedSource:
        """Generate a module containing all modified tools.

        This creates a standalone module that can be imported to
        add the modified tools to an agent.
        """
        lines = [
            '"""Auto-generated module containing modified agent tools.',
            "",
            "This module was generated by the agent's commit_changes() method.",
            '"""',
            "",
            "from agentself import tool",
            "",
        ]

        for name, change in changes.tools.items():
            lines.append(f"# Modified: {name}")
            lines.append(self.generate_tool_source(name, change.current_source))
            lines.append("")

        content = "\n".join(lines)
        is_valid, error = self.validate_source(content)

        return GeneratedSource(
            filename="_modified_tools.py",
            content=content,
            is_valid=is_valid,
            validation_error=error,
        )

    def generate_agent_class(self, changes: AgentChanges) -> GeneratedSource:
        """Generate a complete agent class definition with all modifications.

        This creates a new agent class that incorporates all the
        runtime modifications.
        """
        agent_cls = type(self.agent)
        class_name = agent_cls.__name__

        # Get all tool implementations
        tool_sources = []
        for name, spec in self.agent._tool_specs.items():
            if name in changes.tools:
                # Use modified source
                source = changes.tools[name].current_source
            else:
                # Get original source
                try:
                    source = inspect.getsource(spec.implementation)
                except (OSError, TypeError):
                    continue

            # Clean up indentation and add decorator if needed
            source = textwrap.dedent(source)
            if not source.strip().startswith("@tool"):
                source = "    @tool\n" + textwrap.indent(source, "    ")
            else:
                source = textwrap.indent(source, "    ")

            tool_sources.append(source)

        # Build the class
        lines = [
            '"""Auto-generated agent class with runtime modifications."""',
            "",
            "from agentself import Agent, tool",
            "",
            "",
            f"class {class_name}(Agent):",
            '    """Generated agent class."""',
            "",
        ]

        # Add system prompt if modified
        if changes.prompt:
            prompt_repr = repr(changes.prompt.current)
            lines.append(f"    system_prompt: str = {prompt_repr}")
            lines.append("")

        # Add tools
        for tool_source in tool_sources:
            lines.append(tool_source)
            lines.append("")

        content = "\n".join(lines)
        is_valid, error = self.validate_source(content)

        return GeneratedSource(
            filename=f"_{class_name.lower()}_generated.py",
            content=content,
            is_valid=is_valid,
            validation_error=error,
        )

    def generate_diff(self, changes: AgentChanges) -> str:
        """Generate a human-readable diff of changes."""
        lines = ["# Agent Modifications", ""]

        if changes.prompt:
            lines.append("## System Prompt")
            lines.append("```")
            lines.append(f"- {changes.prompt.original[:50]}...")
            lines.append(f"+ {changes.prompt.current[:50]}...")
            lines.append("```")
            lines.append("")

        if changes.tools:
            lines.append("## Modified Tools")
            for name, change in changes.tools.items():
                lines.append(f"### {name}")
                lines.append("```python")
                lines.append(change.current_source)
                lines.append("```")
                lines.append("")

        return "\n".join(lines)


def write_generated_source(source: GeneratedSource, output_dir: Path) -> Path:
    """Write generated source to a file."""
    if not source.is_valid:
        raise ValueError(f"Cannot write invalid source: {source.validation_error}")

    output_dir.mkdir(parents=True, exist_ok=True)
    output_path = output_dir / source.filename
    output_path.write_text(source.content)
    return output_path
